package main

import (
	"context"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
)

func mapPostgreSQLTypeToGo(pgtype string, isNullable bool) string {
	var goType string

	switch pgtype {
	// integer types
	case "smallint", "integer", "int", "int4":
		goType = "int"
	case "bigint", "int8":
		goType = "int64"
	case "smallserial", "serial", "serial4":
		goType = "int"
	case "bigserial", "serial8":
		goType = "int64"

	// string types
	case "character varying", "varchar", "character", "char", "text":
		goType = "string"

	// Float types
	case "real", "float4":
		goType = "float32"
	case "double precision", "float8":
		goType = "float64"
	case "numeric", "decimal":
		goType = "float64"

	// boolean
	case "boolean", "bool":
		goType = "bool"

	// Date/Time types
	case "timestamp", "timestamp without timezone", "timestamp with time zone", "timestamptz":
		goType = "time.Time"
	case "date":
		goType = "time.time"
	case "time", "time without timezone", "time with time zone", "timetz":
		goType = "time.Time"

	// UUID
	case "uuid":
		goType = "string" // or could be uuid.UUID if using a UUID package

	// JSON types
	case "json", "jsonb":
		goType = "string"

	// Array types (simplified)
	case "ARRAY":
		goType = "[]string" // simplified, would need more complex handling for typed arrays

	// default fallback
	default:
		goType = "interface{}" // unknown types
	}

	if isNullable && goType != "interface{}" {
		goType = "*" + goType
	}

	return goType
}

func generateStruct(tableName string, columns []ColumnInfo) string {
	structName := toPascalCase(tableName)

	var structBuilder strings.Builder
	structBuilder.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, col := range columns {
		// convert column name to go field name
		fieldName := toPascalCase(col.Name)

		jsonTag := strings.ToLower(col.Name) // use original snake_case for JSON
		dbTag := col.Name                    // use original column name for database

		// handle nullable fields in JSON (omitempty for pointers)
		if col.IsNullable {
			jsonTag += ",omitempty"
		}

		tags := fmt.Sprintf("`json:\"%s\" db:\"%s\"`", jsonTag, dbTag)

		structBuilder.WriteString(fmt.Sprintf("\t%s %s %s\n", fieldName, col.GoType, tags))
	}

	structBuilder.WriteString("}")
	return structBuilder.String()
}

// convert snake_case to PascalCase
func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}

	return strings.Join(parts, "")
}

func getTableColumns(ctx context.Context, dbpool *pgxpool.Pool, tableName string) ([]ColumnInfo, error) {

	columnQuery := `
        SELECT 
			c.column_name,
			c.data_type,
			c.is_nullable,
			CASE 
				WHEN pk.column_name IS NOT NULL THEN true 
				ELSE false 
			END as is_primary_key
		FROM information_schema.columns c
		LEFT JOIN (
			SELECT ku.table_name, ku.column_name
			FROM information_schema.table_constraints tc
			JOIN information_schema.key_column_usage ku
				ON tc.constraint_name = ku.constraint_name
				AND tc.table_schema = ku.table_schema
			WHERE tc.constraint_type = 'PRIMARY KEY'
				AND tc.table_schema = 'public'
		) pk ON c.table_name = pk.table_name AND c.column_name = pk.column_name
		WHERE c.table_schema = 'public' 
		AND c.table_name = $1
		ORDER BY c.ordinal_position
        `

	rows, err := dbpool.Query(ctx, columnQuery, tableName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var columns []ColumnInfo
	for rows.Next() {
		var columnName, dataType, isNullable string
		var isPrimary bool

		err := rows.Scan(
			&columnName,
			&dataType,
			&isNullable,
			&isPrimary,
		)
		if err != nil {
			return nil, err
		}

		nullable := isNullable == "YES"
		goType := mapPostgreSQLTypeToGo(dataType, nullable)

		// store column info for struct generation
		columns = append(columns, ColumnInfo{
			Name:         columnName,
			GoType:       goType,
			IsNullable:   nullable,
			IsPrimaryKey: isPrimary,
		})

	}

	return columns, rows.Err()

}

func generateGoFile(packageName string, tableName string, structCode string) string {
	var builder strings.Builder

	builder.WriteString(fmt.Sprintf("// Code generated by sql-to-go on %s\n", time.Now().Format("2006-01-02 15:04:05")))
	builder.WriteString("// DO NOT EDIT - This file was automatically generated\n\n")

	// package declaration
	builder.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// imports (only add if needed)
	if strings.Contains(structCode, "time.Time") {
		builder.WriteString("import \"time\"\n\n")
	}

	// table comment
	builder.WriteString(
		fmt.Sprintf("// %s represents the %s table\n", toPascalCase(tableName), tableName),
	)

	// struct code
	builder.WriteString(structCode)
	builder.WriteString("\n")

	return builder.String()
}

func generateCombinedFile(packageName string, allStructs []string) string {
	var builder strings.Builder

	// File header
	builder.WriteString(fmt.Sprintf("// Code generated by db-struct-generator on %s\n", time.Now().Format("2006-01-02 15:04:05")))
	builder.WriteString("// DO NOT EDIT - This file was automatically generated\n\n")

	builder.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Check if we need time import
	needsTimeImport := false
	for _, structCode := range allStructs {
		if strings.Contains(structCode, "time.Time") {
			needsTimeImport = true
			break
		}
	}

	if needsTimeImport {
		builder.WriteString("import \"time\"\n\n")
	}

	for i, structCode := range allStructs {
		if i > 0 {
			builder.WriteString("\n")
		}

		builder.WriteString(structCode)
		builder.WriteString("\n")
	}

	return builder.String()
}

func writeToFile(filePath string, content string) error {
	formattedContent, err := format.Source([]byte(content))
	if err != nil {
		fmt.Printf("⚠️  Warning: Failed to format %s: %v\n", filepath.Base(filePath), err)
		formattedContent = []byte(content)
	}

	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.Write(formattedContent)
	return err
}
